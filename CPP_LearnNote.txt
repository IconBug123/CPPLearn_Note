025 April 10

C++和C语言的区别
引用，
动态空间开辟
函数重载
string数据类型(类)
bool类型 (内存空 = 1byte) true 和 false 对应的int值为 1和0
C++结构体里可以有函数

关键字default，delete noexcept......


vector<int> a{....};  { }初始化 (即：类 std::initializer_list<T>)， 同样可以operator=(initializer_list<T>的参数)，从而避免 a = {....};  {....}的隐式转换(不提倡)
而vector<int> a={....}; 要经历一个隐式转换再调用构造函数, 如果explicit { }形式构造函数, 则该表达式不能调用了

a = {.....}; 调用initializer_list 赋值函数, 此时{......}是一个initializer_list的匿名对象
如果没有对应的initializer_list的赋值函数，则此时{......}先进行隐式转换成一个匿名的a类型的对象然后进行赋值操作.
iterator / reverse_iterator / const_iterator是类里嵌套的另一个类 class A{....using iterator = class B{......}};  所以：类 vector<int>::iterator itr(对象名)

对于ClassVector a = {1,2,3};而言：
std::initializer_list<int> temp = {1, 2, 3};  隐式转换
ClassVector a(temp);
当使用了explicit修饰构造函数initializer后就不能用这个方法了。

同样的，当a={1,2,3};如果没有相应的initializer_list的赋值函数则也是先构造一个{1,2,3}的ClassVector的匿名对象然后通过默认或自己定义的ClassVector赋值函数

① 
...① 
(1) 命名空间定义: namespace SpaceA{......}  作用域 (防止函数，变量，类的名字冲突)
    使用：SpaceA::函数或变量；
        
        多个空间嵌套namespace A{namespace B{......} ......}   A::B::member_B;    
	C++17里可以namespace A::B{......}
        
	匿名空间namespace{......}  只能在所在区域使用里面的内容, 如同static
        	  
	
	同名的命名空间如果再次创建他们会共享内容	

// mylib.h
namespace mylib {
    void publicFunction();  //函数声明
}
// mylib.cpp
namespace {
    void internalHelper() {// 私有}
}
void mylib::publicFunction(){internalHelper();}
或: namespace mylib{void publicFunction(){internalHelper();}}


(2) using的使用:
	(a) 引入名称(函数名，变量名，空间类名)到所在作用域
	    using namespace SpaceA; 把整个命名空间引入所在作用域, 但一般不提倡,由于可能不同空间有同名成员
	    using SpaceA::member; 同样在继承类里可以引入基类的功能(using Base::func;)
 		
	(b) 给类型起别名(替代了typedef的功能)
	    using uint = unsigned int;               (typedef unsigned int uint;)
	    using cout = std::cout; 


(3) auto
	编译器会根据初始化表达式自动推导出变量类型 auto x = value;（可以结合引用）不能用于函数参数
	
	for (auto x : y) x为变量名首元素的拷贝，遍历有 begin() 和 end() 的 y, (标准容器、数组、自己写的类)，
	由于该方法一开始会记录这个数据的结束位置, 所以不能在遍历的时候修改数据(添加或删除)，因为会导致结束位置混乱


(4) 类型转换
	隐式类型转换:	系统自动进行. 

	显示类型转换:	C语言里的是(int)3.2  C++的为下述内容：
		使用方法：强制转换关键字<类型>(变量)
		1: static_cast：用于大多数安全的转换，编译器在编译期检查合法性。
		2: dynamic_cast：用于多态类型（含虚函数的类）的指针或引用之间转换，带类型检查。
			RIIT dynamic_cast：对象指针的转换， 转换要明确原本的类型避免无法转换  基类里必须有虚函数即多态情况因为需要虚函数表指针 
			(如Base b;里面没有子类信息所以无法转换成子类，而Base* ap = &c; ap可以动态转换为C因为ap动态类型原本就是C
		3: const_cast：用于去除 const 或 volatile 限定的类型（前提：原本不是常量才安全）
		4: reinterpret_cast：几乎不进行任何类型检查，指针强转（直接按内存解释）。
		
	
 dynamic_cast 的使用条件：
1. 必须有继承关系
用于在类的继承体系中进行指针或引用的安全类型转换。

2. 必须有虚函数（即多态类型）
至少一个虚函数才能启用 RTTI（运行时类型识别）机制。

3. 可以用于普通继承，也可以用于虚继承
虚继承不是必要条件；但在虚继承中，dynamic_cast 是唯一安全的方式，因为偏移量是运行时才能确定的。













 ...② 函数高级
  1  C++里函数可以有默认参数，默认值后面的参数都要有默认参数
      函数的声明有默认参数，函数的定义就不能有，因为二义性，因此声明和实现只能有一个有默认参数 
 
  2    函数的占位参数 : func(int) 或 func(int=5)，使用时要给占位参数实值除非有默认值 (operator有的可以不写占位的参数值)

  3    函数重载判断是否是重载：1同一个作用域下，2函数名相同，3函数参数类型不同，4参数个数不同，5参数顺序不同
      (可以用占位参数构建函数重载，函数重载要避免二义性)
      函数重载 = 同一个作用域+相同函数名 + 不同参数列表(参数类型，参数个数，参数顺序)  (注意不要出现二义性)

	 func(const int& a) 和func(int& a)构成函数重载，当func(10)是func(const int& a)
	 但是如果不是引用 const不能构成重载

  4    尾返回形式：auto (arguments)->return_data_type{......}

	     
 
...③ 动态内存
new / delete

int* ptr = new int(5); 或 int* ptr = new int; 没有初始化
int* arr = new int[5];          5个元素的数组, (此处arr不是数组名, 只是一个连续动态首地址）

delete ptr;    如果ptr = nullptr可以释放多次，但是ptr≠nullptr 则不能重复释放
delete[]  arr;  

C++11用{ }替代（ ）更安全 即new int{5};


...④ 引用
引用时给一个变量起别名，他们共同指向一个内存空间 (无论左值还是右值引用)
引用必须初始化，初始化后不能再令其改引到另一个变量。(一直绑定该变量)
引用的用处是为了减少传参是出现的临时变量拷贝现象(函数栈帧问题)
Tip: 作为函数的返回值(可以让返回值作为左值使用)，或是函数形参 (代替指针，从而不需要形参开辟空间进行赋值过程)
左值引用：
	int a = 10;
	int& b = a;   int (&arr_2)[7] = arr_1; void (*& fun_2)(arguments) = fun_1;
右值引用：
	不可以int& b = 10; 但可以const int& b = 10;（此处建立了 int tmp = 10; b是一个不可修改左值即引用tmp）
	int&& b =10; 是一个右值引用，引用的是10这个右值。此时b是左值可修改 
	右值一般用在临时变量 (移动语义)  std::move()将变量转换为右值





--------------------------------------------------------------------------------------------------------------------------------------------------
② 类的封装 Encapsulation

场景		 		| 构造函数执行			| 析构函数执行
局部对象 			| 创建时调用	 		| 离开作用域时自动调用
全局对象 			| 程序开始时调用 		| 程序结束时调用
new 动态对象 		| new 时调用 			| delete 时调用
静态成员对象 		| 程序结束时销毁		| 与全局对象一样



嵌套：类A里面封装类B(有类A权限的影响)，封装的类B不属于类A的对象只是作用域关系
has-it：是指类B里面有类A的对象作为成员变量, 从而可以通过B的对象调用这个A的对象从而访问类A(有权限限制不是友元) Note that: A构造函数的调用

1 构造函数
	1：默认构造(系统有自己的，如果自己定义了就会用定义的) 

	2：有参数构造 (则不会调用系统默认的无参构造函数，除非自己再定义一个无参构造) 
	
	     用初始化列表（初始化，而在{...}是赋值过程对于const成员变量就不能用）
		类B里有类A的对象做为成员，当构造B时也要调用A的构造


	3：拷贝构造 (深浅拷贝: 浅拷贝(默认)是指两个对象的指针是同一地址，深拷贝是不同地址)   
					类B里有类A的对象最为成员，当拷贝构造B时也要调用A的，B的拷贝赋值也要调用A的拷贝赋值
	     classN a = b; b发生隐式转换，而classN a(b); 如果类型匹配b没有隐式转换, 除非是b在隐式转换成相应的内容    当explict时就不能用=初始化
	    ClassName(const ClassName& other){new新内存; 数据拷贝;}    当ClassN* optr = new ClassN(obj); 会用拷贝构造，深拷贝避免重复释放空间问题

	4：转移构造 (把原来的对象的数据传递给新的对象，原来的对象数据=0和nullptr) 要用move(<class> origin_obj)触发, std::move()是强行转换为右值, (移动构造/函数触发条件是obj_1是右值)。
	     如果没有自己定义的移动构造函数，也没有自己定义的拷贝构造函数, 则为默认移动构造 (只是浅拷贝, 不安全)  		   		     
	     ClassName(ClassName&& other){数据转移，地址=nullptr(避免重复释放);

	     Note that: 拷贝/转移构造的参数是引用, 否则就是会无限递归由于函数的参数是一个临时变量且拷贝实参的值

	5：重用构造：一个构造函数里使用另一个构造函数


	**** 1 类里的拷贝函数：<class>& CpyFunc(const <class>& obj_1) {.....; return *this;}         使用：obj_2 . cpy_func(obj_1);

	**** 2 类里的转移函数:  <class>& MovFunc(const <class>&& obj_1) {......; return *this;}     使用：obj_2 . std::move(obj_1);

	a.operator=(b); 如果不是引用则会出现临时对象 (参数触发拷贝构造，返回值触发拷贝构造); 由于拷贝/转移函数之后是临时变量	  	
	c=b=a 就是 (c.operator=(b)).operator=(a)   用引用可以实现链式功能 (不会在中间产生临时变量和拷贝构造)

	☆☆☆ 说明构造函数可以重载
	构造函数先构造内部的成员在构造这个对象
	类的指针ClassN* obj = new ClassN(other或...)或new ClassN[num];(要有无参构成) 会调用拷贝构造或普通构造 (对象在堆空间创建的)，
	即使是：cN arr[2]; 此处也会调用无参构造函数2次构造2个对象，而cN* arr_ptr[2]; 没有调用构造函数(此处是nullptr指针)
	
	匿名对象使用完在下一行就会析构
	

2 析构函数
	~ClassName(){......}  默认，写入delete释放空间, 或关闭文件，析构函数不能重载 (该类有多少个不同对象就会在最后析构几次)
	注意当有开辟空间时, 不要用浅拷贝，要用深拷贝，避免析构时释放同一空间多次
	析构的顺序与构造相反
	对应类指针(堆区上的对象) cN* a = new CN(); 需要delete a; 或delete[] arr; 程序自动调用析构函数
	


3 友元
	
	类B或函数func通过friend声明在类A里，B和func可以通过A类的对象访问A的所有成员(变量和函数)。
	友元不是类A的内容从而没有对应的A对象的this
	友元：友元只能通过(类成员/外部)函数通过对象去访问该类的信息
	****友元可以通过所在的类的对象去访问该类的所有成员，由于友元不是类的成员，所以不受访问权限(private public protected)的影响


4 inline
	1 内联函数是建议编译器在调用函数的地方，用函数体替换函数调用语句，以减小函数调用的开销，提高执行效率。
	   类内定义函数都是隐式inline, 在类外定义的(类内声明)要手写inline才可以
	
	2 在.h文件里定义函数, 但是在多个.cpp里使用这个.h文件会出现多次定义问题(链接过程)，因此要用inline

	应用场景：用于小而频繁代码
	 


5 static成员(函数/变量)
	类的不同对象对应的成员信息都是各自的，只有static成员是共享的
	属于整个类，不是属于某个对象, 所有对象共享同一份数据，没有this
	(1). 静态成员变量在类内声明，要在类外定义(初始化 如：int a = 10; 定义时候不写static) (因为static变量只初始化一次, 类内不允许分配内存) 
	      (不直接属于类的static变量可以直接初始化，如类内成员函数里的局部static变量不需要类外初始化)
	      (Tip: static const成员变量不太一样）
	(2). 静态成员函数只能直接访问静态成员变量 (没有具体对象,（this), 无法确定非成员变量的具体值，每个对象的成员都有各自的值)，
	      但可以通过传入对象(参数)访问非static成员
	
	类名::变量名 访问，不需要对象，也可以对象访问但不推荐

	静态变量生命周期从程序开始到结束
	


6 const成员和mutable修饰
	const对象只能读取成员变量(不能修改)和const成员函数(因为是const this)。(可以修改mutable成员变量)
	const函数只能读取成员变量(不能修改)和const成员函数(因为是const this)   (除非是mutable成员变量非const, 或非this的对象)
	但可以通过其他对象传参修改
	
	mutable 修饰可以被const修饰的内容修改 (mutable只用于修饰变量)。
	const修饰后为只读形式
      （const优先级高与mutable）(const修饰后不能修改，因此不能通过函数间接修改)
	 


7 this指针
	指向“当前正在使用的对象的指针 （常在在成员函数里的使用, ClassName* const this 只能指向当前对象不能指向其他对象）
	在const成员函数里是const ClassName* const this  
	
	1 区分成员变量和函数参数名重复 this->a = a; (左a是该对象的，右a是参数)
	2 实现链式调用（返回 *this  当前对象的引用）
	
	Tip: 在 const 成员函数中变成 const CN*  const this（不能修改对象）
	       实现自赋值判断（如 if (this == &other)）
	       (友元和static没有this)       


8 类的作用域和访问控制 public、private、protected、命名空间
	修饰符 		| 中文含义 	| 对象外部可访问？	| 子类可访问？ 	| 本类可访问？
	public 		| 公有成员 	| ✅ 可以访问 		| ✅ 可以访问 	| ✅ 可以访问
	protected 	| 受保护成员 	| ❌ 不能访问 		| ✅ 可以访问 	| ✅ 可以访问
	private 		| 私有成员 	| ❌ 不能访问 		| ❌ 不能访问 	| ✅ 可以访问	



9 运算符重载operator
	<data_type> operator符号(arguments) {......}  根据需要设定返回类型和形参类型
	
	类内定义：*this对象→符号→参数  （只有一个参数）    符号→*this (没有参数)    仿函数的参数不固定
	类外定义：first参数→符号→second参数	(两个参数)      符号→参数 (一个参数)    一般通过friend函数访问类内部成员  

	ostream& operator<<(ostream& os, const Person& p) {
   	     os << "姓名: " << p.name << ", 年龄: " << p.age;
    	     return os;
	}
	(C++的类型转换函数operator <type>(){.....} 通常结合 static_cast<Type>(expression) 把expression转换为Type类型)
	(Tip: cout是类ostream的对象)



10 常用的关键字(用来修饰函数)
	常用的关键字default noexcept delete 
	=default 使用默认的情况 (也可以有其他重载函数)
	=delete 禁止使用某种情况
	noexcept 不抛出异常, (一般是移动构造和移动赋值函数) 函数末尾
	explicit防止隐式类型转换 (一般是单参数的函数和类型转换构造函数) 函数开头



--------------------------------------------------------------------------------------------------------------------------------------------
③ 继承 inhritance
1：继承的语法
（1）class 父类名 {
	    // 父类成员
	};
	class 子类名 : (virtual )继承方式 父类名 {  (不同的继承方式决定继承过来的Base成员的访问权限的变化)
    		// 子类自己的成员
	};
	is-a 和 has-a关系
	嵌套关系彼此相互独立只是作用域划分的关系

	子类转换为父类时会丢失自己的数据只保留父类的数据，因为Base b = d (子类对象) 这个过程里是调用的Base的拷贝构造Base(const Base&);
	此时隐式转换把子类转换为基类 (切片slicing) 可以用显示转换static_cast<const Base&>(d); explicit的修饰隐式转换避免
	同理: 当子类里调用：Base:: operator=(const Base& other)   void Base::operator=(d); 也是如此, 

（2）注：Derived对象创建时在子类构造里调用Base的构造，否则为Base默认构造)
	无论是继承来的父类（is-a），还是组合的成员对象（has-a），只要它们没有默认构造函数，都必须在子类构造函数的初始化列表中手动初始化。
	
	is-a和has-a一起使用：构造函数：先Base → 再成员对象 → 最后子类对象
	
	多态时 父类析构函数必须是 virtual 如果用 Base* ptr = new Derived(); delete ptr; 没有 virtual 的话，
	只会调用 Base::~Base() 由于静态绑定，子类析构函数不会被调用，内存泄露
	
	在子类写了自己的拷贝构造函数，一定要显式调用父类拷贝构造函数  拷贝构造函数在继承中不会自动调用父类的！
	赋值运算符重载时，也需手动调用父类赋值 	
	要在初始化列表里写父类的相关构造函数
	(以上都是由于函数的重定义导致的)
	
	多层继承中，子类可以直接重写祖父类函数；想调用祖父类函数，直接 d.GrandBase::func() 即可，不需要通过中间类。
	多层 using 不冲突，但任何一层的“重定义”会遮蔽它上面所有层里继承的类的同名函数；
	多层继承里每个类的基础函数(构造和赋值)都显示包含父类的(除非是默认的)
	
	****************总结 (2)*************：
	1 子类的基础函数要涉及到直接继承类和底层虚继承类（如: 基础函数里要调用它们的构造，拷贝, ......；）但不能涉及间接继承类
	
	2 子类可以调用直接继承类, 间接继承类，虚继承类的成员 (当没有继承路径的二义性时)
	
	**********************************Note that总结：
		1 类与类的嵌套
		2 has-a组合
		3 is-a继承： (1): 继承基础(权限)  (2) 普通继承和虚继承  (3) 子类的基础函数注意事项(总结(2) 见上面)
	
		补充：在虚继承中，虚基类（如 A）的构造和析构权力属于最底层子类（如 D），中间类（B、C）即使显式写了 A()，也不会影响对象的实际构造流程
			  虚继承里子类继承后的对象的内存结构: 虚函数表指针vfptr(只想自己vftable)，生成一个虚类表指针(vcptr), 自己的成员 (类里：虚函数表(重写)，继承的虚类表(初始虚继承类的偏移量)，如果是虚继承虚继承的新的虚类表)
			 
		（C虚继承->B虚继承->A）	子类虚继承的对象结构：生成一个vbptr   (类级别存储的虚类表)，继承之前的虚类表     此处C里的虚类表有两个: C虚继承B生成的（记录C->B偏移量）从B继承的（记录B->A偏移量）
		******子类虚继承：对象的内存结构包含：虚函数表指针(如果有的话，指向自己的虚函数表), 生成一个虚类表指针(指向自己的虚类表C->B), 继承虚类表指针(指向)， 自己的成员
					   类内存结构包含: 虚函数表（重写），生成虚类表(与上一级的偏移量)，继承虚函数表  
			 普通继承里：全部继承过来（嵌入形式）不会生成（自己的虚类表和虚类表指针）

class C size(28):
        +---
 0      | {vfptr}
 4      | {vbptr}
        +---
        +--- (virtual base A)
 8      | {vfptr}
12      | a
        +---
        +--- (virtual base B)
16      | {vfptr}
20      | {vbptr}
24      | b
        +---




2 继承的函数重定义(隐藏)和重写(覆盖)
	(1)重定义: 子类中定义了与父类只要同名的函数 (参数列表和返回值可以不同), 会隐藏父类的所有同名函数。
		没有 virtual 也会生效。
		参数列表不需要完全相同。(只要名字一样，父类的被继承，但被隐藏了无法被子类对象直接调用) 
		不支持支持多态	
		作用域不同	

	****重定义(隐藏): 
				子类只在他所在的作用域里查找该函数。遮蔽上一层的同名函数
				也可以：Base::fun(......); 去Base作用域里调用，可以用using Base::B_fun; 引入这个作用域从而让Base里的重载的函数在子类可以用
					(必须在子类的同名函数前面，当同名同参则还是子类的)
				只能静态绑定（编译期决定调用哪个函数）
				不支持支持多态


	(2)重写: 子类中定义了与父类参数完全相同的 virtual 函数，并且在父类中的函数为 virtual，
		函数名、参数列表、返回值完全相同
		父类函数开头是 virtual		
		支持多态	
		子类函数后面建议加 override（C++11）	 建议（防止写错） 除非 derived_obj.Base::func(...);

	****重写(覆盖):
				1 Derived把从Base继承的的虚函数表里的函数替换成自己的虚函数
				2 可以通过  Base::B_fun(......)去调用，using也无法使用Base的因为是替换(另外这些函数不是重载)
				3 动态绑定（通过对象的指针或引用调用），静态绑定(其他调用方式，根据对象的定义量而言)   动态或静态是取决于调用方式
				（运行期决定调用哪个函数）注: Base* pb = new Derived();  (*pb).Base::fun(); 但不能 pb->Base::fun();  由于运算顺序里的 ->Base::不成立
				4 支持多态
				
	访问父类被重定义或重写函数：d_obj.Base::Bfunc(...); （只要这个函数在当前作用域下有可访问权限）
	Base::fun() 只能通过对象名如static成员 或者 在子类内部使用 Base::fun()来调用
	
	
	Base* ptr = new Derived();   静态类型是变量定义时的类型Base*    
						      动态类型运行时该指针实际指向的对象类型Derived
	对应static成员可以obj.Der::Base::member; 或 Der::Base::member 调用	
	

 多层继承和多继承(归为总结里的)
   	一个类同时继承多个基类，多继承可以直接获得多个父类的功能
	如果两个父类中有同名函数只能通过作用域来明确调用哪个父类(避免二义性) （如：c.A::show(); c.B::show(); 或using A::show;）
	
	在菱形继承里: 
		普通继承多个子类会出现每个子类各拷贝一份基类, 导致底层类(继承多个子类的底层)调用基类时有多条路径到每个子类各自的基类，
		可以让多个中间子类虚继承virtual基类所有路径共享同一份基类从而所有路径使得底层类到唯一的基类，或者也可以使用 last_obj.MID::Top::成员
		如果没有菱形的虚继承，则底层类创建对象时每个路径都会创建一个基类 （底层构造函数只包含上一层类的构造函数）
		如果有菱形虚继承，则底层类构造函数要包含上层类和基类构造函数。（底层类负责构造基类，而中间层类的基类的构造不会执行, 除非是构造中间层） 			
		用虚继承可以确定二义性时子类继承的唯一路径，由于中间继承类的继承了虚基类指针都指向虚基类的成员，而不是每个中间继承了都有自己的一个继承。
	
   A        			     A
  /          				\
  B(embed A)           	C(embed A)
   \         				/
      			D    ← 有两份 A（冲突）
  
      A      ← 虚基类，只保留一份
     / \
    B   C
     \ /
      D     ← D 统一持有 A，路径唯一
	
	Note that: 
	在虚继承里: B ，C都是继承了一个A的偏移指针而不是直接嵌入基类的子对象, 
	只有最底层子类才能直接嵌入基类的子对象从而直接拥有基类子对象，避免多路径问题（嵌套在另一个对象内部的对象部分）
	子对象（subobject）**指的是：
		一个对象中由于继承或成员嵌套而存在的嵌套对象部分。
		它的类型是类成员或基类。
	
	（多层继承有虚继承，普通继承混合使用，注意子类的基础函数和二义性，虚继承主要是解决继承路径的二义性问题）
	（虚继承类时候基类嵌套在最底层类里，(最底层类是：最后一个虚继承子类或第一个普通继承子类)）

		
普通继承
class B size(8):
+---                         ← 类 B 对象开始
| +--- (base class A)        ← A 子对象嵌套在 B 中
| | dataA                    ← A 的成员变量
| +---                       ← A 结束
| dataB                      ← B 的成员变量
+---                         ← 类 B 对象结束

class C size(8):
+---                         ← 类 C 对象开始
| +--- (base class A)        ← A 子对象嵌套在 C 中
| | dataA                    ← A 的成员变量
| +---                       ← A 结束
| dataC                      ← C 的成员变量
+---                         ← 类 C 对象结束

class D size(20):
+---                           ← 最外层类 D
| +--- (base class B)          ← B 子对象（从 D 继承）
| | +--- (base class A)        ← A 子对象嵌套在 B 内部
| | | dataA                    ← A 的成员
| | +---                       ← A 结束
| | dataB                      ← B 的成员
| +---                         ← B 结束
| +--- (base class C)          ← C 子对象（从 D 继承）
| | +--- (base class A)        ← A 子对象又嵌套在 C 内部
| | | dataA                    ← A 的成员（第二份）
| | +---                       ← A 结束
| | dataC                      ← C 的成员
| +---                         ← C 结束
| dataD                        ← D 自己的成员
+---                           ← D 结束



虚继承
class B size(12):
+---                         ← 类 B 对象开始
| {vbptr}                    ← 虚基表指针（指向偏移表）
| dataB                      ← B 自己的成员
| +--- (virtual base A)      ← B 虚继承的 A
| | dataA                    ← A 的成员
| +---                       ← A 结束
+---                         ← 类 B 结束

class C size(12):
+---                         ← 类 C 对象开始
| {vbptr}                    ← 虚基表指针（指向偏移表）
| dataC                      ← C 自己的成员
| +--- (virtual base A)      ← C 虚继承的 A
| | dataA                    ← A 的成员
| +---                       ← A 结束
+---                         ← 类 C 结束

class D size(24):
+---                               ← 类 D 对象开始
| +--- (base class B)              ← B 子对象（继承自 D）
| | {vbptr}                        ← B 的虚基表指针
| | dataB                          ← B 的成员
| +---                             ← B 结束
| +--- (base class C)              ← C 子对象（继承自 D）
| | {vbptr}                        ← C 的虚基表指针
| | dataC                          ← C 的成员
| +---                             ← C 结束
| dataD                            ← D 的成员
| +--- (virtual base A)            ← 唯一的 A 子对象（由 D 构造）
| | dataA                          ← A 的成员
| +---                             ← A 结束
+---                               ← 类 D 结束

一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。

bptr指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。
虚基类表存储的是虚基类相对直接继承类的偏移；而虚函数表存储的是虚函数地址。
Refer to: https://blog.csdn.net/longlovefilm/article/details/80558879

虚继承时候会创建一个虚类表指针和虚类表，继承虚嵌入（基类的信息，以及虚类表）


| 用法                          | 位置     | 作用                 |
| --------------------------- | ------ | ------------------ |
| `class ClassName final {}`  | 类定义处   | 禁止这个类被继承           |
| `virtual void func() final` | 虚函数声明处 | 禁止该虚函数被子类 override |
| `override final` 组合使用       | 虚函数声明处 | 重写父类函数并禁止再次重写      |


.....




-----------------------------------------------------------------------------------------------------------
④ 多态 Polymorphism

	用函数重定义或重载实现的是静态多态，用虚函数实现的是动态多态
	
	(2) 1 动态多态的条件：
		  继承关系
		  Base* 或 Base& = &Derived 或 new Derived(...)；   （Base* bptr = &d;）    
		  (虚函数里的关键字：virtual, override, final 的使用)            final 在末尾修饰表示不可被继承或是不可重写
		Base的指针或是引用指向的是: 子类里继承(嵌入)的基类的子对象(成员，虚函数表(被重写的)，虚函数表指针(指向所在的子类的虚函数表), ....)的地址
		所以也可知道这个Base指针或引用不能调用子类里的扩展的成员

	2（构造期间虚函数调用是无效的（此时 vptr 尚未完整构造）由于vptr是在构造期间建立（指的是：即使你在构造函数中调用虚函数，
	最终调用的也只会是当前类的版本，而不会多态地调用派生类重写的版本））
	
	2********构造函数里调用虚函数只是自身类里的，因为他们彼此还没有建立动态联系(Base* bptr = &der); this->虚表指针还是指向自己的虚函数表
		      构造函数不能是virtual和纯虚函数 (因为vptr没建立，this->constructor(...)没有vptr)	
	
	2  多态里Base的析构函数必须是 virtual，否则只是静态绑定了基类的析构函数，而不能触发多态导致子类没有析构。
	   如果Base的析构是纯虚析构函数必须要提供定义
	   
	   	
	❌在单一继承链或无二义性的普通多继承中，A* ap = &c; 是合法的。(A→B→C) 二义性时要A* ap = static_cast<B*>(&d);明确中间过渡的路径 
	在虚继承编译器无法静态推导 → 必须使用 dynamic_cast （虚继承中，子对象位置不是固定偏移是由vbtable决定）
	
	1 Note that: 普通继承(无二义性): Base* bptr = &d;    有二义性的普通继承: A* ap = static_cast<B*>(&d);明确中间过渡的路径 
			  虚继承: Base* bptr = dynamic<Base*>(&d);
			
		Base& ref = d;        // ✅ 只是引用，不复制，不切片
		Base* ptr = &d;       // ✅ 指针同理，不切片，不复制
		const Base& cref = d; // ✅ 只是引用，不复制，不切片
		Base b = d;  // ← 这里发生了“切片”
		它只是引用了 d 对象在内存中的真实地址，不会构造新的对象，也不会复制，所以 子类对象仍然完整存在，这叫做：多态绑定
	
	(1) 	  	  
	Note that: 
	 	1 虚函数都是存在该类的虚函数表里，虚表指针 = &虚函数表，虚函数表是类级别(所以对象共享)，虚表指针是对象级别(每个对象有自己的)
	 	2 子类继承了每个基类的虚函数表，覆盖重写虚函数, 没重写的保持原样 每个虚函数表都有一个虚表指针 (多继承时子类对于每个基类都有一个虚函数表和虚表指针)
	    	   如：BaseA* ptrA = &d; 此时的虚表指针就是子类的（继承BaseA的重写后的虚函数表的指针）
	 	3 多态原理：因为类通过指针或是引用调用虚函数时都是通过此时类的指针或是引用所对应的虚表指针找到对应的虚函数表调用这些虚函数指针,
                            从而根据虚表指针的不同调用不同的函数版本
			   (调用虚函数时如果是类的指针或是引用，则通过虚函数表调用的是动态版本，否则调用的是静态版本，非虚函数用什么方式调用都是静态版本)
	  
		final和override关键字，final只能修饰virtual函数和类，修饰后不能被重写，也不能被继承
	
	(3) 抽象类是指：包含至少一个纯虚函数的类 如：纯虚函数virtual void f() = 0;
				抽象类不能实例化，只能作为接口（interface）或基类存在，
				用来让子类强制实现某些函数，子类不重写这些纯虚函数，则子类也是抽象类
				

	(4) RTTI (Running Time Type Information)
		是 C++ 中的一个特性，用于在程序运行时识别对象的真实类型，尤其在多态（polymorphism）体系下非常有用。
		| 功能             | 用途              | 示例                                |
		| -------------- | --------------- | --------------------------------- |
		| `typeid`       | 获取对象的实际类型       | `typeid(*ptr).name()`             |
		| `dynamic_cast` | 在继承体系中安全地进行类型转换 | `dynamic_cast<Derived*>(basePtr)` |

    		Base* b = new Derived;
    		std::cout << typeid(*b).name() << std::endl; // 输出 Derived 类型（注意*号）
    		std::cout << typeid(b).name() << std::endl;  // 输出 Base* 类型（指针本身）
		
		RIIT dynamic_cast：对象指针的转换， 转换要明确原本的类型避免无法转换  基类里必须有虚函数即多态情况因为需要虚函数表指针 



class Base {
public:
    virtual void show() { std::cout << "Base\n"; }
};

class Derived : public Base {
public:
    void show() override { std::cout << "Derived\n"; }
};

int main() {
    Derived d;

    d.show();          // ✅ 非指针/引用，静态绑定
    Derived* dp = &d;
    dp->show();        // ✅ 指针，动态绑定

    Base& br = d;
    br.show();         // ✅ 引用，动态绑定

    Base b;
    b.show();          // ✅ 非指针/引用，静态绑定（调用 Base::show）
}


多态里子类都会创建一个自己的虚函数表指针，


不可以被定义成虚函数
内联函数
构造函数
静态成员函数：static成员函数是属于类的。不属于任何对象。
友元函数：不支持继承，没有实现为虚函数的必要
赋值运算符：赋值运算符要求形参类型与本身类型相同，基类中赋值操作符形参为基类类型，即使声明成虚函数，也不能作为子类的赋值操作符



cl main.cpp /d1reportSingleClassLayoutB




		   	
	
	当A <-v- B <-v- C：
class C size(32):
        +---
 0      | {vfptr}
 4      | {vbptr}
 8      | c
        +---
        +--- (virtual base A)
12      | {vfptr}
16      | a
        +---
        +--- (virtual base B)
20      | {vfptr}
24      | {vbptr}
28      | b
        +---


	当A <-v- B <-- C：
class C size(24):
        +---
 0      | +--- (base class B)
 0      | | {vfptr}
 4      | | {vbptr}
 8      | | b
         | +---
12     | c
        +---
        +--- (virtual base A)
16      | {vfptr}
20      | a
        +---
		

	当A <-- B <-- C：
class C size(16):
        +---
 0      | +--- (base class B)
 0      | | +--- (base class A)
 0      | | | {vfptr}
 4      | | | a
        | | +---
 8      | | b
        | +---
12      | c
        +---





--------------------------------------------------------------
1< 模版Template的基础>

① 模版的格式
函数模版的格式:
template<typename T1, typename T2, ......>      表示声明一个模板, T是类型参数  typename表示后面的T是一个数据类型
T fun(T_arguments){......}                     一个泛型函数, 接受任意类型的参数只要fun符合逻辑
使用方法: fun<data_type>(......);


类模版的格式:
template<typename T1, typename T2, ......>
class CN {
    成员关于T1, T2, ...的类型;
};
类外定义的成员fun
template<typename T1, typename T2, ......>
Ti CN<T1, T2, ...>:: fun(T_arguments){......}
类对象
CN<data_type> obj;


Ti可以有默认参数, 如: template<typename T1, typename T2 = int, ......> 后面的都要有默认参数
关键字typename和class可以互换 (当T里有嵌套的依赖数据类型名时要用typename修饰)

*****Note that: typename T::type_value  表示type_value是T模版参数(类)里嵌套的数据类型, 如果没有typename则可能是T里的一个成员变量（C++会把T::type_value当作static成员变量）除非编译器知道T::type_value是一个类型(非依赖名)	

template<typename U>
struct MyBox {
    using data_type = U;
};

template<typename T>
void func() {
    typename T::data_type val;  // ✅ 合法，只要 T 有 data_type
}

func<MyVector<double>>();  // 则 T = MyVector<double>


② 非类型模版参数
模板参数不一定非得是“类型”（typename T），它也可以是一个常量值！

template<typename T, data_type par>
T func<具体参数,...>(argument){......}
使用方法: func<int, val>(......);   val必须是编译期间已知的值
	
在使用func时候<>里的非类型模版参数必须是编译时就已知的:
	整型常量（<>里直接赋值的int, char, bool，const int或constexpr int变量）除非是C++20才有其他类型的常量
	指针常量（如函数指针或全局变量指针）
	枚举值
Note that: 不能是变量 (如int a = 10; fun<int, a>❌)



总结:
1模版参数的设置   
	(1) template<typename T, data_type par, template<typename> class BT>
		
	① 类型模版参数: typename T    (T是数据类型, 也可以是类)
	   
	② 非类型模版参数: data_type par  
	    (非类型模版参数在实例化时必须在编译阶段就是已知的, 如: 整型常量(int, char, bool, enum), 指针常量(函数指针, 对象指针, nullptr), ...)

	③ 类模版模版参数 template<typename CT1, ...> class CNT    
	    (实例化时不能有<参数>. 如果不是类模板模板参数而是用类模版作为类型模版参数, 则CNT<参数>)
	    

	Note that:    (1) 参数可以有默认值, 但默认值后面的参数都要有默认值
			    (2) 非类型模版参数par的数据类型可以是类型模版参数T, 如: template<typename T, T par>)
			    (3) typename修饰的变量是数据类型 (当依赖于模版时, 即模板上下文中), template修饰的变量是一个模版 (当依赖于模版时, 即模版上下文中) 
				 在非依赖上下文里不能使用 typename 和 template
			 
	 	(类或模版类里嵌套数据类型: typename CN::data_type 从而区分这个不是一个成员, 而是数据类型)
	    	(类或模版类里嵌套的模板类: typename CN_A<...>::template CN_B<...> B_obj, 如果是实例化, 则不能用template和typename, 
		 如果不是模版, 则不使用template) 



   (2) func和class模版
① func模版
	函数模板定义
	template<typename T, data_type par, template<typename> class BT>
	RT func(arguments of T, ...){关于 T 和 par......}     
	
	函数模板使用
	func<Real_Parameters>(Real_arguments);

	(Note that: func的返回类型可以是明确的数据类型也可以是模版参数)



② class类模版
	类模板定义
	template<typename T, data_type par, template<typename> class BT>
	class CN{
	    RT func(......); 类内的普通成员func	
	    
	    template<typename U, ......> 类内定义的成员函数模版
	    RT func_T(......);
	   
            friend void func<>(CN<T, par, BT> obj);  类的友元模版(要在类模板的前面定义)
	};
	
	类外定义的普通成员func
	template<typename T, data_type par, template<typename> class BT>
	RT CN<T, par>:: func(arguments of T){关于T和par......}  
	
	类外定义的成员func模版
	template<typename T, data_type par, template<typename> class BT>
	template<typename U, ...>
	RT CN<T, par>:: func_T(arguments of T){关于T和par......}  
	
	友元func类外实现  
	template<typename T, data_type par, template<typename> class BT>   ☆☆类模板声明在类模版定以前
	class CN; 
	template<typename T, data_type par, template<typename> class BT>  
	void func(CN<T, par, BT> obj){......} 或是声明 void func(CN<T, par, BT> obj);  友元声明, 然后在类之后定义

	使用过程: 
	class<Real_Parameters> obj();
	obj.func(...);
	obj.func<实例化参数>(...);


Note that:
   (1) 调用优先级: 同名func或类 > 模版  (如果模版能更好的匹配则优先调用模版) 
   (2) 模版分文件写时, 调用模版的文件要#include<template.cpp>而不是template.h因为模版是编译期间定义的, 或者把模版都写到.hpp文件里(表示
	这个文件里是模版) 模版在头文件里被多个文件调用不会出现重复定义现象 (函数模版也可以用inline)
   (3) 实例化模版template MODEL<具体参数>; 然后再其他.cpp文件里extern template MODEL<具体参数>从而减少使用模版时的实例化次数
------------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------
类模版里嵌套类模板的使用: typename A<...>::template B<...> B_obj;
模版里嵌套：(1) 类型，(2) 类模板

当模版里嵌套类模版时候
template<typename T>
class A {
public:
    template<typename U>
    class B {
    public:
        U data;
    };
};

template<typename T>
void func() {
    typename A<T>::template B<int> b;  // ✅ 注意：必须加 template
}
此处typename A<T>::template B<int> b;  表示A<T>里的成员template B<int>是b的数据类型(该数据类型是类模版)
在实例化使用时候: A<int>::B<double> B_obj; 不能用typename和template
----------------------------------------------------------------------------------------------
例子 template<typename T, int size, template<typename> class BT>
#include <iostream>
using namespace std;

// 模板模板参数（BT）
template<typename U>
class Box {
public:
    U value;
};

// 使用类型 + 非类型 + 模板模板参数
template<typename T, int size, template<typename> class BT>
class Container {
private:
    BT<T> array[size];  // 包含 size 个 Box<T>
public:
    void set(int index, const T& val) {
        array[index].value = val;
    }
    void show(int index) const {
        cout << "Value[" << index << "] = " << array[index].value << endl;
    }
};

int main() {
    Container<int, 3, Box> c;
    c.set(0, 100);
    c.set(1, 200);
    c.set(2, 300);

    c.show(0);
    c.show(1);
    c.show(2);
}
--------------------------------------------------------------------------------

2 模版的全特化和偏特化
	全特化:  所有模板参数都被指定具体类型
	偏特化:  只对部分模板参数进行特化 (只用于类模板, 不能用于函数模版, 一般用函数模版重载(再写一个函数模版))

	template<typename T, template<.....> class CNT, data_size par,...>
	.....

	template<没有特化的模版参数typename T, int size, template<typename> class BT>
	func<特化全部模版参数>或 class CNT<特化某些或全部模版参数 + 非特化参数>  (Note that: 按照模版参数顺序)


模版隐式实例化时会剥夺const和引用等信息, 或出现引用折叠
引用折叠: 根据实参类型自动推导引用类型
数组参数 → 退化为指针
函数参数 → 退化为函数指针



3 CRTP (Curiously Recurring Template Pattern)
派生类将自己作为模板参数传给基类，形成一种特殊的“模板继承关系

RTP 实现的关键是：
不使用虚函数
在编译期完成派生类的行为替换（静态多态）
零运行时开销！比虚函数快

template<typename Derived>
class Base {
public:
    void interface() {
        static_cast<Derived*>(this)->impl();
    }
};

class Derived : public Base<Derived> {
public:
    void impl() {
        std::cout << "Derived::impl() 被调用\n";
    }
};

int main() {
    Derived d;
    d.interface();  // 输出 Derived::impl()
}


4 模版参数包(了解) 可变参数模版
	
		X... args 表示数据形式是X的参数包args (args里是X类型的各种参数) X也可以是一个数据类型包(里面是各种数据类型)
	        如:
	            template<typename... T>  typename...表示 T 是一包类型模版参数
	            void func(T... args){......}      T... 表示 args 是一包形参   sizeof...(args)表示形参的个数  sizeof...(T)表示类型模版参数的个数
 

	(1) 可变参数函数模版
		void func(){
			.......   递归结束
		}
		template<typename T, typename... U>		一个类型模版参数, 和一包模版参数的形式最适合参数包展开
		void func(T& first_arg, U&... other_args){
			std::cout<<first_arg<<std::endl;
			func(other_args...);     此处other_args就是一个形参包
		}  


	(2) 可变参数类模板
		(a) 继承递归展开:
		template<typename... Args> class TCN{};
		template<> class TCN<>{......}; 没有参数的特化类模板
		template<typename FirstArg, typename... Args>
		class TCN<FirstArgs, Args...>: private TCN<Args...>{.....};   反向递归
		
		(b) 组合递归展开

	
	(3)元组展开
	tuple






========================================================================
STL (Standard Template Library)

Introduction:
C++ 标准库中用模板实现的一套通用数据结构与算法集合。
它的核心设计思想是 “算法与数据结构分离，通过迭代器连接”
容器负责存数据  → 迭代器负责把数据交给算法  →  算法负责处理数据。

STL 并不是只有“容器”，而是由 6 个部分构成的生态系统：
| 模块                                | 作用                                                                  | 例子                                            					|
| ------------------ ------| ------------------------------------------ | -------------------------------------------------------------|
| **容器 Containers**       | 存储和组织数据的结构                                 | `vector`, `list`, `map`, `set`, `deque`       					|
| **算法 Algorithms**      | 各种数据处理算法（排序、查找、统计等）   | `sort`, `find`, `count`, `accumulate`         				|
| **迭代器 Iterators**       | 统一的遍历接口，像“容器的指针”    	      | `vector<int>::iterator`                       					|
| **函数对象 Functors**   | 可以像函数一样调用的对象                           | `greater<int>`, 自定义比较器                        				|
| **适配器 Adapters**      | 对容器或函数做功能改装                              | 容器适配器：`stack`, `queue`；迭代器适配器：`back_inserter`|
| **分配器 Allocators**    | 控制容器的内存分配策略         		      | `std::allocator`                              						|


模块之间的工作机制
数据容器（Containers）
     ↓（提供迭代器接口）
迭代器（Iterators）
     ↓（作为算法的输入输出）
算法（Algorithms）
     ↑（可能用到函数对象）
函数对象（Functors）
另外，适配器是一个“包装器”，能让某个组件换一种用法；分配器则决定容器的内存分配方式。


-------------------------------------------------------------------------------------------------------------
1容器

① 顺序容器
数据结构: 链表和动态数组
| 容器                	    | 特点                 			 | 底层        |
| ----------------- | ---------------------------------- | --------|
| vector<T>         | 动态数组，支持随机访问，尾部插入快      | 连续内存 |
| deque<T>          | 双端队列，支持头尾插入        		 | 分段数组 |
| list<T>           | 双向链表，中间插入快，但无法随机访问  | 指针链表 |
| forward_list<T>   | 单向链表，适用于低开销操作                     | 单向链表 |
| array<T, N>       | 固定大小数组，封装内置数组                     | 静态数组 |

使用建议：
访问速度优先 → vector
频繁插入删除 → list
两端操作多 → deque
低内存场景 → forward_list
固定数据量 → array


② 有序关联容器
数据结构：使用的是红黑树和平衡二叉树，元素是按排序顺序组织的。
| 容器               | 键是否唯一 | 自动排序 | 使用场景        |
| ---------------- | ----- | ---- | ----------- |
| `set<T>`         | 是     | 是    | 唯一集合        |
| `multiset<T>`    | 否     | 是    | 允许重复集合      |
| `map<K, V>`      | 是     | 是    | 键值对映射（键唯一）  |
| `multimap<K, V>` | 否     | 是    | 键值对映射（键可重复） |

适用场景：
自动排序（红黑树结构）
查找、插入、删除都是 O(log n)
迭代器遍历是有序的
键不可修改（修改键可能破坏排序）
需要有序遍历（如排行榜）


③ 无序关联容器
数据结构：基于哈希表，效率高但不保证顺序
容器	                    键是否唯一	         排序	使用场景
unordered_set<T>	      是	                  否	   快速查找集合
unordered_multiset<T>	否	                  否	   允许重复集合
unordered_map<K,V>	      是	                  否	   快速键值映射
unordered_multimap<K,V>	否	                  否	   多键键值映射

适用场景：
查找性能要求高，但不关心顺序（如字典、缓存）
需要快速判断元素是否存在




顺序容器：顺着来，按顺序存
有序容器：红黑树，排序查
无序容器：哈希表，快查找
适配容器：换接口，限操作



|    分类   	 | 是否排序     		| 查找效率      		| 插入/删除效率        		 | 底层结构  	| 典型容器                           		 |
| ---- 	 | -------- 		| --------- 		| -------------- 			 | ----- 		| ------------------------------ 	 |
| 顺序容器 | 按插入顺序    		| O(n)（需遍历） 	| 取决于位置（数组/链表差异） | 数组、链表 	| vector, deque, list            		 |
| 有序容器 | 自动排序     		| O(log n)  		| O(log n)       			         | 红黑树   	| set, map                       			 |
| 无序容器 | 无序（哈希存储）  | 平均 O(1)   		| 平均 O(1)        			 | 哈希表   	| unordered\_set, unordered\_map |

-----------------------------------------------------------------------------------------------------------------------------------------------------------

顺序容器
(1) vector  
	   底层是动态数
	   连续内存存储 → 随机访问速度快（O(1)）
	   自动扩容 → 插入新元素时会自动分配更多内存
	   尾部插入删除效率高 → O(1) 平均
	   中间插入/删除效率低（需要移动元素） → O(n)


| 方法           | 作用       | 是否检查越界 | 复杂度  | 特点                            |
| ------------ | -------- | ------ | ---- | ----------------------------- |
| `operator[]` | 下标访问元素   | ❌ 否    | O(1) | 快，不安全                         |
| `at()`       | 下标访问元素   | ✅ 是    | O(1) | 安全，越界抛 `std::out_of_range` 异常 |
| `front()`    | 返回第一个元素  | ❌ 否    | O(1) | 不能空容器调用                       |
| `back()`     | 返回最后一个元素 | ❌ 否    | O(1) | 不能空容器调用                       |

所有访问函数返回引用，可以直接修改元素：


| 函数                      | 作用           | 返回值 | 复杂度     | 注意点           |
| ----------------------- | ------------ | --- | ------- | ------------- |
| `push_back(const T&)`   | 尾部插入一个元素（拷贝） | 无   | 摊销 O(1) | 可能触发扩容（迭代器失效） |
| `push_back(T&&)`        | 尾部插入一个元素（移动） | 无   | 摊销 O(1) | C++11 起支持     |
| `emplace_back(args...)` | **原地构造**尾部元素 | 无   | 摊销 O(1) | 避免额外拷贝/移动     |
| `pop_back()`            | 删除最后一个元素     | 无   | O(1)    | 不返回值，不能删除空容器  |


push_back vs emplace_back 区别
| 场景       | `push_back`    | `emplace_back`         |
| -------- | -------------- | ---------------------- |
| 插入已构造的对象 | ✔️ 直接拷贝/移动     | ✔️ 效果相同                |
| 插入需要临时对象 | 先构造临时对象，再拷贝/移动 | **直接在容器中构造**（少一次拷贝/移动） |

v.push_back(Person("Tom", 18));    // 构造临时 Person，再拷贝/移动进 vector
v.emplace_back("Tom", 18);         // 直接在 vector 内构造 Person
pop_back() 不能获取被删除的值，如果需要返回值，应先保存



扩容机制与迭代器失效
vector 内存是连续的，容量满时，push_back 会：
    分配更大的内存（通常是当前容量的 2 倍）
    把旧数据移动/拷贝过去
    释放旧内存
一旦重新分配内存：
    所有迭代器失效
    所有指向元素的指针失效
    所有引用失效

vector 高效三原则
	1 能尾插不中插
	2 能预分配就预分配
	3 能移动就不拷贝

vector有bool这个特殊化形式
位操作 + 代理封装，会比普通 vector<char> 慢。


总结:
vector的数据结构: 动态数组 (连续内存), 容量满时分配更大的内存 (通常是当前容量的2倍)把旧数据移动/拷贝过去并且释放旧内存
重新分配内存后, 之前的所有使用的迭代器, 所有元素的指针, 所有元素的引用都会失效 (由于重新分配了内存, 导致之前元素的指针和引用没有指向元素的新地址, 所以就无效了), 因此每次重新分配内存后, 之前使用的迭代器, 元素的指针, 元素的引用都要重新获取

vector特点
	1 尾插速度快, 不建议中插(速度慢)
	2 能预分配就预分配 reserve(num_capacity)避免频繁开辟空间
	3 能移动就不拷贝
	4 如果只是遍历, 查找, 排序, 则用 vector

vector有bool这个特殊化形式
位操作 + 代理封装, 会比普通 vector<char> 慢。

容器里面有相关的增删查改成员函数, insert, erase, push, find, ...等



2 list

std::list 是一个 双向链表 容器：
每个节点存储数据 + 前驱指针 + 后继指针
优点：
任意位置插入/删除都是 O(1)（已知位置迭代器的前提下）
插入/删除不会导致其他元素迭代器失效

缺点：
不支持随机访问（it + n 不可用）
每个节点有额外指针开销（内存占用大于 vector）
遍历性能比 vector 慢（不连续内存，缓存命中率低）


插入/删除后：
所有其他元素的迭代器仍然有效
被删除元素的迭代器失效
与 vector 相比：
vector → 随机访问快，尾部增删快
list → 任意位置增删快，不支持随机访问



总结:
list的数据结构: 双链表, 不是连续内存, (不能迭代器+n), 元素之间的链接是通过指针 (因此不能通过迭代器随机访问, 只能按顺序一个个访问)
插入/删除后所有其他元素的迭代器仍然有效, 被删除元素的迭代器失效
非连续内存的数据没有capacity

特点:
	1 任意位置增删速度快
	2 遍历性能比vector慢 (不连续内存, 相邻元素之间通过指针链接查找)
	3 迭代器不能随机访问 (没有[ ]访问)
	4 如果频繁在中间插入/删除, 则用 list

容器里面有相关的增删查改成员函数, insert, erase, push, find, ...等
list自己的成员函数(splice, merge, sort, uniqe, ...)

===========================================================
list里的splice把list_1的元素移动到list_2或list_1的不同位置, 被移动的list将失去该元素
splice不拷贝, 不移动元素, 只改指针, O(1) 操作。
list1.splice(pos, list2);                    // list2 全部转移到 list1 的 pos 之前
list1.splice(pos, list2, it);                 // 转移 list2 中的单个元素 it
list1.splice(pos, list2, first, last);        // 转移 list2 中的 [first,last) 区间

list里的merge合并两个有序链表, 被合并的list变为空, 默认用 < 比较, 也可以传自定义比较器

sort, unique
============================================================



3 deque
deque的数据结构：是分段连续存储(连续的小内存块+中央控制表(map/索引表)), 扩容时只需增加新块，原来		的块完全不动, 支持两端快速插入和删除
		迭代器会失效由于数据有连续存储的结构(与vector相同的情况)
特点:
	1 每个数据块(连续内存结构)如同vector, 不同的数据块(链表结构)如同list
	2  适合于两端操作 + 偶尔随机访问 (随机访问速度比vector慢)



------------------------------------------------------------------------
4 forward_list
forward_list的数据结构: 单链表, 不是连续内存, (不能迭代器+n, 也不能向前访问--it), 元素之间的链接是通过指针 (因此不能通过迭代器随机访问, 只能按顺序一个个访问)
插入/删除后所有其他元素的迭代器仍然有效, 被删除元素的迭代器失效
非连续内存的数据没有capacity

特点：
	1 forward_list是一个轻量级的链表结构, 没有push_back(因为要从开头节点才能找到最后的节点位置)
	2 适合于在开头插入数据
	3 单链表只有"前插"和"删除某个位置之后的节点" (有一个前置迭代器表示第一个元素之前位置)


5 array

固定大小：大小在编译期确定，不能增删元素
内部是连续内存（和 vector 一样），支持随机访问迭代器
和普通 C 数组性能相同
支持 STL 容器接口（begin、end、size 等）
可以安全地按值传递、赋值

#include <array>
std::array<类型, 大小> 名字;

总结:
array的数据结构: 静态数组 (连续内存, 创建后不能扩容, 固定长度),而C语言里的数组类似

特点:
	1 可以使用data()成员函数获取array的首元素地址用于与C语言API交互
	2 在动态内存里capacity()和size()表示容量和目前元素个数, 而静态内存里没有capacity()



6 string
动态数组(连续内存), 底层通常实现为类似 std::vector<char> 的结构,

特点:
	1 内部会在末尾放一个 '\0'(方便与 C 字符串兼容)
	2 成员函数 c_str() 获取 C 风格字符串指针返回 const char*
	3 元素类型: char 或  wchar_t / char16_t / char32_t 取决于具体类型别名


==================================================================================================================================================================
container总结:
1 顺序容器
① vector
vector数据结构: 动态数组 (连续内存), 容量满时分配更大的内存(通常是当前容量的2倍)把旧数据移动/拷贝过去并且释放旧内存
重新分配内存后, 之前的所有使用的迭代器, 所有元素的指针, 所有元素的引用都会失效 (由于重新分配了内存, 导致之前元素的指针和引用没有指向元素的新地址, 所以就无效了), 
因此每次重新分配内存后, 之前使用的迭代器, 元素的指针, 元素的引用都要重新获取

vector特点
	1 尾插速度快, 中间插入速度慢
	2 能预分配内存就预分配 reserve(num_capacity)避免频繁开辟空间
	3 如果只是遍历, 查找, 排序, 则用vector

    vector有bool这个特殊化形式
        位操作 + 代理封装, 会比普通 vector<char> 慢。



② list
list数据结构: 双链表, 不是连续内存, (不能迭代器+n), 元素之间的链接是通过指针, 因此不能通过迭代器随机访问, 只能按顺序一个个访问
插入/删除后所有其他元素的迭代器仍然有效, 被删除元素的迭代器失效, 非连续内存的数据没有capacity

特点:
	1 任意位置增删速度快
	2 遍历性能比vector慢 (不是连续内存, 相邻元素之间通过指针链接查找)
	3 迭代器不能随机访问 (没有[ ]访问)
	4 如果频繁在中间插入/删除, 则用 list

（list自己的成员函数(splice, merge, sort, uniqe, ...)）



③ forward_list
forward_list数据结构: 单链表, 不是连续内存, (不能迭代器+n, 也不能向前访问--it), 元素之间的链接是通过指针 (因此不能通过迭代器随机访问, 只能按顺序一个个访问)
插入/删除后所有其他元素的迭代器仍然有效, 被删除元素的迭代器失效
非连续内存的数据没有capacity

特点：
	1 forward_list是一个轻量级的链表结构, 没有push_back(因为要从开头节点才能找到最后的节点位置)
	2 适合于在开头插入数据
	3 单链表只有"前插"和"删除某个位置之后的节点" (有一个前置迭代器表示第一个元素之前位置)


④ deque
deque数据结构：是分段连续存储(连续的小内存块+中央控制表(map/索引表)), 扩容时只需增加新块，原来的块完全不动, 支持两端快速插入和删除
	      迭代器会失效, 由于数据有连续存储结构(与vector相同的情况)
特点:
	1  每个数据块(连续内存结构)如同vector, 不同的数据块(链表结构)如同list
	2  适合于两端操作 + 偶尔随机访问 (随机访问速度比vector慢)



⑤ array
array数据结构: 静态数组 (连续内存, 创建后不能扩容, 固定长度), 与C语言里的数组类似

特点:
	1 可以使用data()成员函数获取array的首元素地址用于与C语言API交互
	2 在动态内存里capacity()和size()表示容量和目前元素个数, 而静态内存里没有capacity(), 没有动态分配



⑥ string
string数据结构: 动态数组(连续内存),  类似 std::vector<char> 的结构

特点:
	1 内部会在末尾放一个 '\0'(方便与 C 字符串兼容)
	2 成员函数 c_str() 获取 C 风格字符串指针返回 const char*
	3 元素类型: char 或  wchar_t / char16_t / char32_t 取决于具体类型别名



2 关联容器
① Map
(1) map数据结构: 红黑树(平衡二叉树)存储键值对, 默认按key升序排列
(2) unordered_map数据结构: Hash Table 无序排列
如: map<int, string> m2{{1,"A"},{2,"B"}}; // 列表初始化 key=int, value=string

特点:
1 insert不会修改已存在的键(对于已存在的键值对不做操作)
2 []会创建或更新键值对, 即便是访问也会创建键值对。
3 同一个key只能出现一次, unordered的键类型必须可哈希 (默认支持基本类型, 如: string, 或自定义哈希函数）


②MultiMap
(1) map数据结构: 红黑树(平衡二叉树)存储键值对, 默认按key升序排列
(2) unordered_multimap数据结构: Hash Table 无序排列

特点:
1 insert可以插入重复的键, 一个 key 对应多个值
2 不能[]访问
3 同一个key可以出现多次, unordered的键类型必须可哈希 (默认支持基本类型, 如: string, 或自定义哈希函数）


③Set
(1) set数据结构: 红黑树 (平衡二叉树) 默认升序排序
(2) unordered_set数据结构: Hash Table 无序排列 

特点:
  元素唯一, 自动去除重复元素


④MultiSet
(1) multiset数据结构: 红黑树 (平衡二叉搜索树) 默认升序
(2) unordered_multiset数据结构: Hash Table 无序排列

特点:
  允许重复元素



Note that: 
容器里面有相关的增删查改成员函数, insert, erase, push, find, ...等
不同的容器都有自己独特的成员函数实现数据操作

随机访问多: vector, deque, string(文本存储)
频繁中间插入/删除: list, forward_list
有序快速查找: 有序关联容器
无序快速查找:  无序关联容器
固定容量, 小数据块: array

---------------------------------------------------------------------------------------------

  (2) 无序关联容器
①unordered_set
unordered_set数据结构: Hash Table 

特点：
1 元素唯一

②unordered_multiset
unordered_multiset数据结构: Hash Table

特点：
1 元素可以重复

③unordered_map
unordered_map数据结构: Hash Table

特点:
1 键是唯一的
2 []会创建或更新键值对, 即便是访问也会创建键值对。
3 键的类型必须可哈希 (默认支持基本类型, 如: string, 或自定义哈希函数）


④unordered_multimap
unordered_multimap数据结构: Hash Table

特点:
1 键可以重复
2 []会创建或更新键值对, 即便是访问也会创建键值对。
3 键的类型必须可哈希 (默认支持基本类型, 如: string, 或自定义哈希函数）


（将有序和无序关联容器合并）

容器里面有相关的增删查改成员函数, insert, erase, push, find, ...等
不同的容器都有自己独特的成员函数实现数据操作


------------------------------------------------------------------------------------------------------

iterator总结:

对容器来说: 迭代器是访问内部元素的唯一通用方式 (不暴露底层结构)
对算法来说: 迭代器提供了统一接口, 不用关心容器类型

container_<data_type> :: iterator it = container. iteratorFun(); 返回值是迭代器的容器成员函数


常见迭代器类型
| 迭代器类型                    	| 说明         			| 常见容器                          |
| ------------------------ 	| ---------- 			| --------------------------  |
| `iterator`               		| 正向迭代器，可读可写 	| `vector`, `list`, `set`, ... 	 |
| `const_iterator`         	| 只读迭代器      		| 所有容器                         |
| `reverse_iterator`       	| 反向迭代器      		| 所有容器                         |
| `const_reverse_iterator`| 只读反向迭代器    		| 所有容器                         |


迭代器类型:
1 普通迭代器: 根据位置遍历容器里的元素
2  插入迭代器: 遍历时向容器插入元素 
3 流迭代器: 把输入流当作容器遍历, 把输出流当作容器写入

不同的容器的迭代器支持的操作形式也不同, 指针也被视为一种迭代器

| 容器                                               | 迭代器操作形式 |
| ------------------------------------------------ | ----- |
| `vector` / `deque` / `array`                     | 随机访问  |
| `list` / `set` / `map` / `multiset` / `multimap` | 双向    |
| `forward_list`                                   | 前向    |
| `unordered_*`                                    | 前向    |


| 对比项      | 指针          | 迭代器                                 |
| -------- | ----------- | ----------------------------------- |
| **本质**   | 变量，存储对象内存地址 | 对象，封装了访问容器元素的方式                     |
| **适用范围** | 只能用于数组或连续内存 | 适用于所有 STL 容器                        |
| **操作限制** | 随机访问、算术运算自由 | 根据迭代器类别限制操作（如 list 不能 `it + 3`）     |
| **安全性**  | 容易越界        | 容器会提供 `begin()` 和 `end()` 保证范围      |
| **失效机制** | 指向的内存被释放会悬空 | 受容器规则限制，可能在插入/删除后失效（vector 扩容会全部失效） |

迭代器失效指的是容器结构发生变化后, 原有迭代器不再指向原来的元素
| 容器                                  | 插入导致的失效                   | 删除导致的失效  |
| ----------------------------------- | ------------------------- | -------- |
| **vector**                          | 扩容 → 所有失效；中间插入 → 插入点及之后失效 | 删除点及之后失效 |
| **deque**                           | 可能全部失效（复杂结构）              | 删除点及之后失效 |
| **list / forward\_list**            | 不会失效                      | 仅被删节点失效  |
| **set / map / multiset / multimap** | 不会失效                      | 仅被删节点失效  |
| **unordered\_* 系列*\*                | 重哈希（rehash）后全部失效          | 仅被删节点失效  |



总结:
1
对容器来说: 迭代器是访问内部元素的唯一通用方式 (不暴露底层结构)
对算法来说: 迭代器提供了统一接口, 不用关心容器类型

container<data_type>::iterator itr = Real_Container.FunIter(); 返回值是迭代器的容器成员函数
(Real_Container是实例化的容器对象)

2 
不同的容器的迭代器支持的操作形式也不同 (指针也被视为一种迭代器)
vector, deque, array 随机访问
list, set, map, multiset, multimap, 双向访问
forward_list, unordered_* 向后访问

3 
迭代器失效指的是容器结构发生变化后, 原有迭代器不再指向原来的元素
由于扩容, 插入新元素导致后面元素位置变化的,元素被删除, Hash Table重建, ... 等原因



algorithm总结:
算法不依赖容器在, 只依赖迭代器类型, 迭代器类型决定了能用哪些算法

1 非修改性算法(只读取不改元素)
for_each 
for_each(1st_iter, last_iter, func)       可调用函数对象(普通函数, 函数对象, lambda) 遍历区间 [1st_iter, last_iter)
(可以在通过func显式修改元素)

find
auto it = find(1st_iter, last_iter, value);  要查找的值需要支持 == 比较
在区间[1st_iter, last_iter)内查找第一个等于给定值的元素。如果找到, 则返回指向该元素的迭代器; 如果没找到, 返回 last_iter

find_if：根据条件查找第一个匹配的元素
find_if_not：查找第一个不匹配条件的元素

for_each, find, count, equal, mismatch
2 修改性算法(会改容器元素)
copy, fill, replace, remove, transform
3 排序与相关算法
sort, stable_sort, partial_sort, nth_element
4 集合与数值算法
set_union, set_intersection, accumulate, inner_product




functor总结:
functor是有仿函数的类的对象调用该仿函数, 通常使用CN()调用仿函数 (此处是CN创建的临时对象调用仿函数)
Lambda表达式本质也是一个有仿函数的类, 通过临时对象调用仿函数
STL里很多功能是通过对象, 因此对象可以直接作为函数对象, 而成员函数要通过bind/mem_fn包装转换
STL里提供了一些常用的functor: 算数类, 比较类, 逻辑类


Lambda表达式
auto func = [capture_list] (parameter_list) -> return_type {
    function_body
};
函数名和返回类型都可以省略由编译器自动推导 (Note that: 仅限简单情况时)
Tip: 在lambda表达式里通过对象调用成员函数, 则lambda表达式可以将成员函数转换为可调用对象 

普通的值捕获默认是 const, 要修改它们需要 mutable
int x = 0;
auto f = [x]() mutable {
    x++;            //直接修改外部x; 如果x+=5; 则是lambda内部的局部变量x, 不是外部的x
    return x;
};
cout << f() << endl; // 输出 1
cout << f() << endl; // 输出 2（修改的是内部副本）

批量捕获外部值简写 (大量使用lambda外部变量)
[=]：按值捕获所有外部变量, 默认为const
[&]：按引用捕获所有外部变量
[=, &x]：默认值捕获，但 x 用引用捕获
[&, x]：默认引用捕获，但x用值捕获
简写只会捕获 lambda 里实际用到的变量, 避免捕获的值悬空(Lambda运行时外部值已不存在)


2. 可调用对象的几种类型
类型	示例	说明
普通函数	int add(int a, int b);	直接调用 add(1,2)
函数指针	int (*pf)(int,int) = add;	调用 pf(1,2)
仿函数（函数对象）	struct F{ int operator()(int x){ return x+1; } }; F f; f(5);	类里重载 operator()
lambda 表达式	[](int x){ return x+1; }(5);	编译器生成匿名仿函数类并实例化
std::function 包装器	std::function<int(int,int)> f = add; f(1,2);	一种类型安全的“万能可调用对象”包装器
bind 生成的对象	auto f = std::bind(add, 10, _1); f(5);	bind 返回的是函数对象





adaptor总结:

| 类别         | 作用                 | 典型例子                                                                       |
| ---------- | ------------------ | -------------------------------------------------------------------------- |
| **容器适配器**  | 改变底层容器接口，变成特殊用途的容器 | `stack`、`queue`、`priority_queue`                                           |
| **迭代器适配器** | 改变迭代器的行为           | `reverse_iterator`、`insert_iterator`、`istream_iterator`、`ostream_iterator` |
| **函数适配器**  | 改变函数对象或普通函数的行为     | `std::bind`、`std::function`、`std::not_fn`、`mem_fn`                         |


1-容器适配器: 改变底层容器接口, 变成特殊用途的容器
① stack (后进先出)
默认用deque作为底层容器, 也可以用vector或list作为底层实现 (底层容器必须支持push_back, pop_back, back, empty, size)
不能直接遍历元素

使用场景:
  括号匹配
    深度优先搜索（DFS）
    撤销（undo）功能
    表达式求值（后缀表达式



② queue (先进先出)
默认用deque作为底层容器, 也可以用list作为底层实现 (底层容器必须支持push_back, pop_back, back, empty, size)

使用场景:
    任务调度（按顺序处理）
    广度优先搜索（BFS）
    消息队列
    打印队列


③ priority_queue
是一种 按优先级出队 的队列，默认是 vector<T>  (底层容器必须支持front(), push_back(), pop_back(), size(), 随机访问)
默认是 less<T> → 大顶堆（最大值优先）内部通常用堆(heap)实现
greater<int> → 小顶堆（最小值优先）


使用场景
任务调度（优先级高的任务先执行）
Dijkstra 最短路径算法
Top-K 问题（找前 K 个最大/最小的数）
事件驱动模拟


| 函数                 | 作用               |
| ------------------ | ---------------- |
| `push(x)`          | 入队（按优先级自动调整位置）   |
| `pop()`            | 出队（删除最高优先级元素）    |
| `top()`            | 访问最高优先级元素        |
| `empty()`          | 队列是否为空           |
| `size()`           | 队列中元素个数          |
| `emplace(args...)` | 原地构造元素并入队（C++11） |






2-迭代器适配器: 改变迭代器的行为
① reverse_iterator
    让容器从尾到头遍历和普通迭代器一样, 写入时会覆盖元素
容器常用接口：rbegin() / rend() 


② insert_iterator
插入迭代器 会把写操作转换为插入操作

常见的三种插入迭代器的适配器
	back_inserter(container)
	把元素追加到容器末尾（调用 push_back）。
	适用于：vector、deque、list

	front_inserter(container)
	把元素插到容器开头（调用 push_front）。
	适用于：deque、list

	inserter(container, pos)
	把元素插入到指定迭代器位置（调用 insert）。
	适用于：所有支持 insert 的容器（如 set、map、vector、list）


③ istream_iterator和ostream_iterator
流迭代器适配器把 输入输出流（cin / cout / 文件流等）当作容器来处理

常见的2种输入输出流迭代器的适配器
	istream_iterator： 把元素从外部(cin, file)逐个读到容器里
	ostream_iterator：把元素从容器逐个写入输出流(cout, file)
它们能和算法（如 copy, for_each 等）配合使用



3-函数适配器
把函数/仿函数转换或包装成能适应STL算法的要求

常见的函数适配器:
std::bind: 把一个可调用对象 (普通函数, 成员函数(需要提供对象), 函数对象, lambda表达式) 转换成一个新的函数对象
std::function: 把一个可调用对象 (普通函数, 成员函数, 函数对象, lambda表达式) 转换成有统一调用接口的函数对象
		     从而可以使不同形式的函数 (lambda, 普通函数, 成员函数, 仿函数) 都能放进一个容器里
std::not_fn: 把一个可调用对象 (普通函数, 成员函数, 函数对象, lambda表达式) 转换成一个新的函数对象且返回结果逻辑取反 (算法需要 "条件为假" 的情况)
mem_fn: 把类的成员函数转换为函数对象 (转换后的函数第一个参数是类的对象), (常用于STL算法里直接调用对象的成员函数, 而不用写lambda)
	       例如: auto fn = mem_fn(&Foo::show); // 把成员函数转成可调用对象
    			Foo f;
			fn(&f, 42);  // 调用 f.show(42)  如同仿函数
		结合bind使用时候: std::bind(std::mem_fn(&CN::memFunc), &obj, other_pars);
                                            等价于: std::bind(&CN::memFunc, &obj, other_pars);



allocator总结:

负责容器内存的申请与释放（new/delete 的封装）。
默认是 std::allocator<T>，几乎所有情况下都够用。

































