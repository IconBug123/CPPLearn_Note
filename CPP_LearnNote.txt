025 April 10

C++和C语言的区别
引用，
动态空间开辟
函数重载
string数据类型(类)
bool类型 (内存空 = 1byte) true 和 false 对应的int值为 1和0
C++结构体里可以有函数



① namespace 和 using
(1) 命名空间定义: namespace SpaceA{......}  作用域 (防止函数，变量，类的名字冲突)
    使用：SpaceA::函数或变量；
        
        多个空间嵌套namespace A{namespace B{......} ......}   A::B::member_B;    
	C++17里可以namespace A::B{......}
        
	匿名空间namespace{......}  只能在所在区域使用里面的内容, 如同static
        命名空间里函数或是变量如果是声明，可以在外部定义<data_type> SpaceA:: fun(arguments){......}
	可以结合匿名空间一起使用，内部程序不暴露，只暴露接口	  

// mylib.h
namespace mylib {
    void publicFunction();  //函数声明
}
// mylib.cpp
namespace {
    void internalHelper() {// 私有}
}
void mylib::publicFunction(){internalHelper();}
或: namespace mylib{void publicFunction(){internalHelper();}}


(2) using的使用:
	(a) 引入名称(函数名，变量名，空间类名)到所在作用域
	    using namespace SpaceA; 把整个命名空间引入所在作用域, 但一般不提倡,由于可能不同空间有同名成员
	    using SpaceA::member; 同样在继承类里可以引入基类的功能(using Base::func;)
 		
	(b) 给类型起别名(替代了typedef的功能)
	    using uint = unsigned int;               (typedef unsigned int uint;)
	    using cout = std::cout; 

	     

② 动态内存
new / delete

int* ptr = new int(5); 或 int* ptr = new int; 没有初始化
int* arr = new int[5];          5个元素的数组, (此处arr不是数组名, 只是一个连续动态首地址）

delete ptr; 
delete[]  arr;  

C++11用{ }替代（ ）更安全


③ 引用
引用时给一个变量起别名，他们共同指向一个内存空间
引用必须初始化，初始化后不能再令其改引到另一个变量。(一直绑定该变量)
Tip: 作为函数的返回值(可以让返回值作为左值使用)，或是形参(代替指针，从而不需要形参开辟空间进行赋值过程)
int a = 10;
int& b = a;   不可以int& b = 10; 但可以const int& b = 10;（此处建立了 int tmp = 10; b是一个不可修改左值即引用tmp）
int&& b =10; 是一个右值引用，引用的是10这个右值。此时b是个左值可修改



④函数高级
  1  C++里函数可以有默认参数，默认值后面的参数都要有默认参数
      函数的声明有默认参数，函数的定义就不能有，因为二义性，因此声明和实现只能有一个有默认参数 
 
  2    函数的占位参数 : func(int) 或func(int=5)，使用时要给占位参数实值除非有默认值

  3    函数重载判断是否是重载：1同一个作用域下，2函数名相同，3函数参数类型不同，4参数个数不同，5参数顺序不同
      (可以用占位参数构建函数重载，函数重载要避免二义性)
      函数重载 = 同一个作用域+相同函数名 + 不同参数列表(参数类型，参数个数，参数顺序)  (注意不要出现二义性)

	 func(const int& a) 和func(int& a)构成函数重载，当func(10)是func(const int& a)
	 但是如果不是引用 const不能构成重载












