025 April 10

C++和C语言的区别
引用，
动态空间开辟
函数重载
string数据类型(类)
bool类型 (内存空 = 1byte) true 和 false 对应的int值为 1和0
C++结构体里可以有函数

关键字default，delete noexcept......


vector<int> a{....};  { }初始化 (即：类 std::initializer_list<T>)， 同样可以operator=(initializer_list<T>的参数)，从而避免 a = {....};  {....}的隐式转换(不提倡)
而vector<int> a={....}; 要经历一个隐式转换再调用构造函数, 如果explicit { }形式构造函数, 则该表达式不能调用了

a = {.....}; 调用initializer_list 赋值函数, 此时{......}是一个initializer_list的匿名对象
如果没有对应的initializer_list的赋值函数，则此时{......}先进行隐式转换成一个匿名的a类型的对象然后进行赋值操作.
iterator / reverse_iterator / const_iterator是类里嵌套的另一个类 class A{....using iterator = class B{......}};  所以：类 vector<int>::iterator itr(对象名)

对于ClassVector a = {1,2,3};而言：
std::initializer_list<int> temp = {1, 2, 3};  隐式转换
ClassVector a(temp);
当使用了explicit修饰构造函数initializer后就不能用这个方法了。

同样的，当a={1,2,3};如果没有相应的initializer_list的赋值函数则也是先构造一个{1,2,3}的ClassVector的匿名对象然后通过默认或自己定义的ClassVector赋值函数


① 
(1) 命名空间定义: namespace SpaceA{......}  作用域 (防止函数，变量，类的名字冲突)
    使用：SpaceA::函数或变量；
        
        多个空间嵌套namespace A{namespace B{......} ......}   A::B::member_B;    
	C++17里可以namespace A::B{......}
        
	匿名空间namespace{......}  只能在所在区域使用里面的内容, 如同static
        命名空间里函数或是变量如果是声明，可以在外部定义<data_type> SpaceA:: fun(arguments){......}
	可以结合匿名空间一起使用，内部程序不暴露，只暴露接口	  
	
	同名的命名空间如果再次创建他们会共享内容	

// mylib.h
namespace mylib {
    void publicFunction();  //函数声明
}
// mylib.cpp
namespace {
    void internalHelper() {// 私有}
}
void mylib::publicFunction(){internalHelper();}
或: namespace mylib{void publicFunction(){internalHelper();}}


(2) using的使用:
	(a) 引入名称(函数名，变量名，空间类名)到所在作用域
	    using namespace SpaceA; 把整个命名空间引入所在作用域, 但一般不提倡,由于可能不同空间有同名成员
	    using SpaceA::member; 同样在继承类里可以引入基类的功能(using Base::func;)
 		
	(b) 给类型起别名(替代了typedef的功能)
	    using uint = unsigned int;               (typedef unsigned int uint;)
	    using cout = std::cout; 


(3) auto
	编译器会根据初始化表达式自动推导出变量类型 auto x = value;（可以结合引用）不能用于函数参数
	
	for (auto x : y) x为变量名首元素的拷贝，遍历有 begin() 和 end() 的 y, (标准容器、数组、自己写的类)，
	由于该方法一开始会记录这个数据的结束位置, 所以不能在遍历的时候修改数据(添加或删除)，因为会导致结束位置混乱


(4) 类型转换
	隐式类型转换:	系统自动进行. 

	显示类型转换:	C语言里的是(int)3.2  C++的为下述内容：
		使用方法：强制转换关键字<type>(express)
		1: static_cast：用于大多数安全的转换，编译器在编译期检查合法性。
		2: dynamic_cast：用于多态类型（含虚函数的类）的指针或引用之间转换，带类型检查。
		3: const_cast：用于去除 const 或 volatile 限定的类型（前提：原本不是常量才安全）
		4: reinterpret_cast：几乎不进行任何类型检查，指针强转（直接按内存解释）。
		
	


 ② 函数高级
  1  C++里函数可以有默认参数，默认值后面的参数都要有默认参数
      函数的声明有默认参数，函数的定义就不能有，因为二义性，因此声明和实现只能有一个有默认参数 
 
  2    函数的占位参数 : func(int) 或 func(int=5)，使用时要给占位参数实值除非有默认值 (operator有的可以不写占位的参数值)

  3    函数重载判断是否是重载：1同一个作用域下，2函数名相同，3函数参数类型不同，4参数个数不同，5参数顺序不同
      (可以用占位参数构建函数重载，函数重载要避免二义性)
      函数重载 = 同一个作用域+相同函数名 + 不同参数列表(参数类型，参数个数，参数顺序)  (注意不要出现二义性)

	 func(const int& a) 和func(int& a)构成函数重载，当func(10)是func(const int& a)
	 但是如果不是引用 const不能构成重载

  4    尾返回形式：auto (arguments)->return_data_type{......}

	     
 
③ 动态内存
new / delete

int* ptr = new int(5); 或 int* ptr = new int; 没有初始化
int* arr = new int[5];          5个元素的数组, (此处arr不是数组名, 只是一个连续动态首地址）

delete ptr;    如果ptr = nullptr可以释放多次，但是ptr≠nullptr 则不能重复释放
delete[]  arr;  

C++11用{ }替代（ ）更安全 即new int{5};


④ 引用
引用时给一个变量起别名，他们共同指向一个内存空间
引用必须初始化，初始化后不能再令其改引到另一个变量。(一直绑定该变量)
Tip: 作为函数的返回值(可以让返回值作为左值使用)，或是函数形参 (代替指针，从而不需要形参开辟空间进行赋值过程)
左值引用：
	int a = 10;
	int& b = a;   int (&arr_2)[7] = arr_1; void (*& fun_2)(arguments) = fun_1;
右值引用：
	不可以int& b = 10; 但可以const int& b = 10;（此处建立了 int tmp = 10; b是一个不可修改左值即引用tmp）
	int&& b =10; 是一个右值引用，引用的是10这个右值。此时b是左值可修改






⑤ 类的封装

场景		 		| 构造函数执行			| 析构函数执行
局部对象 			| 创建时调用	 		| 离开作用域时自动调用
全局对象 			| 程序开始时调用 		| 程序结束时调用
new 动态对象 		| new 时调用 			| delete 时调用
静态成员对象 		| 程序结束时销毁		| 与全局对象一样



嵌套：类A里面封装类B(有类A权限的影响)，封装的类B不属于类A的对象只是作用域关系
has-it：是指类B里面有类A的对象作为成员变量, 从而可以通过B的对象调用这个A的对象从而访问类A(有权限限制不是友元) Note that: A构造函数的调用

1 构造函数
	1：默认构造(系统有自己的，如果自己定义了就会用定义的)

	2：有参数构造 (则不会调用系统默认的无参构造函数，除非自己再定义一个无参构造) 
	
	     用初始化列表（初始化，而在{...}是赋值过程对于const成员变量就不能用）

	3：拷贝构造 (深浅拷贝: 浅拷贝(默认)是指两个对象的指针是同一地址，深拷贝是不同地址)  
	     classN a = b; b发生隐式转换，而classN a(b); 如果类型匹配b没有隐式转换, 除非是b在隐式转换成相应的内容    当explict时就不能用=初始化
	    ClassName(const ClassName& other){new新内存; 数据拷贝;}    当ClassN* optr = new ClassN(obj); 会用拷贝构造，深拷贝避免重复释放空间问题

	4：转移构造 (把原来的对象的数据传递给新的对象，原来的对象数据=0和nullptr) 要用move(<class> origin_obj)触发, std::move()是强行转换为右值, (移动构造/	     函数触发条件是obj_1是右值)。如果没有自己定义的移动构造函数，也没有自己定义的拷贝构造函数, 则为默认移动构造 (只是浅拷贝, 不安全)  		   		     ClassName(ClassName&& other){数据转移，地址=nullptr(避免重复释放);

	     Note that: 拷贝/转移构造的参数是引用, 否则就是会无限递归由于函数的参数是一个临时变量且拷贝实参的值

	5：重用构造：一个构造函数里使用另一个构造函数


	**** 1 类里的拷贝函数：<class>& CpyFunc(const <class>& obj_1) {.....; return *this;}         使用：obj_2 . cpy_func(obj_1);

	**** 2 类里的转移函数:  <class>& MovFunc(const <class>&& obj_1) {......; return *this;}     使用：obj_2 . std::move(obj_1);

	a.operator=(b); 如果不是引用则会出现临时对象 (参数触发拷贝构造，返回值触发拷贝构造); 由于拷贝/转移函数之后是临时变量	  	
	c=b=a 就是 (c.operator=(b)).operator=(a)   用引用可以实现链式功能 (不会在中间产生临时变量和拷贝构造)

	☆☆☆ 说明构造函数可以重载
	构造函数先构造内部的成员在构造这个对象
	类的指针ClassN* obj = new ClassN(other或...)或new ClassN[num];(要有无参构成) 会调用拷贝构造或普通构造 (对象在堆空间创建的)，
	即使是：cN arr[2]; 此处也会调用无参构造函数2次构造2个对象，而cN* arr_ptr[2]; 没有调用构造函数(此处是nullptr指针)

	

2 析构函数
	~ClassName(){......}  默认，写入delete释放空间, 或关闭文件，析构函数不能重载 (该类有多少个不同对象就会在最后析构几次)
	注意当有开辟空间时, 不要用浅拷贝，要用深拷贝，避免析构时释放同一空间多次
	析构的顺序与构造相反
	对应类指针(堆区上的对象) cN* a = new CN(); 需要delete a; 或delete[] arr; 程序自动调用析构函数
	


3 友元
	
	类B或函数func通过friend声明在类A里，B和func可以通过A类的对象访问A的所有成员(变量和函数)。友元不是类A的内容从而	没有对应的A对象的this
	友元：友元只能通过(成员/外部)函数通过对象去访问该类的信息
	****友元可以通过所在的类的对象去访问该类的所有成员，由于友元不是类的成员，所以不受访问权限(private public protected)的影响


4 inline
	1 内联函数是建议编译器在调用函数的地方，用函数体替换函数调用语句，以减小函数调用的开销，提高执行效率。
	   类内定义函数都是隐式inline, 在类外定义的(类内声明)要手写inline才可以
	
	2 在.h文件里定义函数, 但是在多个.cpp里使用这个.h文件会出现多次定义问题(链接过程)，因此要用inline

	应用场景：用于小而频繁代码
	 


5 static成员(函数/变量)
	类的不同对象对应的成员信息都是各自的，只有static成员是共享的
	属于整个类，不是属于某个对象, 所有对象共享同一份数据，没有this
	(1). 静态成员变量在类内声明，要在类外定义(初始化) (因为static变量只初始化一次, 类内不允许分配内存) 
	      (不直接属于类的static变量可以直接初始化，如类内成员函数里的局部static变量不需要类外初始化)
	      (Tip: static const成员变量不太一样）
	(2). 静态成员函数只能直接访问静态成员变量 (没有具体对象,（this), 无法确定非成员变量的具体值，每个对象的成员都有各自的值)，
	      但可以通过传入对象(参数)访问非static成员
	
	类名::变量名 访问，不需要对象，也可以对象访问但不推荐

	静态变量生命周期从程序开始到结束
	


6 const成员和mutable修饰
	const对象只能读取成员变量(不能修改)和const成员函数(因为是const this)。(可以修改mutable成员变量)
	const函数只能读取成员变量(不能修改)和const成员函数(因为是const this)   (除非是mutable成员变量非const, 或非this的对象)
	但可以通过其他对象传参修改
	
	mutable 修饰可以被const修饰的内容修改 (mutable只用于修饰变量)。
	const修饰后为只读形式
      （const优先级高与mutable）(const修饰后不能修改，因此不能通过函数间接修改)
	 


7 this指针
	指向“当前正在使用的对象地址的指针 （常在在成员函数里的使用,this == ClassName* const obj）
	在const成员函数里是const ClassName* const 或const this
	
	1 区分成员变量和函数参数名重复 this->a = a; (左a是该对象的，右a是参数)
	2 实现链式调用（返回 *this  当前对象的引用）
	
	Tip: 在 const 成员函数中变成 const A*  const this（不能修改对象）
	       实现自赋值判断（如 if (this == &other)）
	       (友元和static没有this)       


8 类的作用域和访问控制 public、private、protected、命名空间
	修饰符 		| 中文含义 	| 对象外部可访问？	| 子类可访问？ 	| 本类可访问？
	public 		| 公有成员 	| ✅ 可以访问 		| ✅ 可以访问 	| ✅ 可以访问
	protected 	| 受保护成员 	| ❌ 不能访问 		| ✅ 可以访问 	| ✅ 可以访问
	private 		| 私有成员 	| ❌ 不能访问 		| ❌ 不能访问 	| ✅ 可以访问	



9 运算符重载operator
	<data_type> operator符号(arguments) {......}  根据需要设定返回类型和形参类型
	
	类内定义：*this对象→符号→参数  （只有一个参数）    符号→*this (没有参数)    仿函数的参数不固定
	类外定义：first参数→符号→second参数	(两个参数)      符号→*this (一个参数)    一般通过friend函数访问类内部成员  

	ostream& operator<<(ostream& os, const Person& p) {
   	     os << "姓名: " << p.name << ", 年龄: " << p.age;
    	     return os;
	}
	(C++的类型转换函数operator <type>(){.....} 通常结合 static_cast<Type>(expression) 把expression转换为Type类型)
	(Tip: cout是类ostream的对象)



10 常用的关键字(用来修饰函数)
	常用的关键字default noexcept delete 
	=default 使用默认的情况 (也可以有其他重载函数)
	=delete 禁止使用某种情况
	noexcept 不抛出异常, (一般是移动构造和移动赋值函数) 函数末尾
	explicit防止隐式类型转换 (一般是单参数的函数和类型转换构造函数) 函数开头




⑥ 继承
1：继承的语法
（1）class 父类名 {
	    // 父类成员
	};
	class 子类名 : 继承方式 父类名 {  (不同的继承方式决定继承过来的Base成员的访问权限的变化)
    		// 子类自己的成员
	};
	is-a 和 has-a关系
	

（2）子类转换为父类时会丢失自己的数据只保留父类的数据，因为Base b = d (子类对象) 这个过程里是调用的Base的拷贝构造Base(const Base&);
	同理: void Base::operator=(b); 也是如此


（3）注：Derived对象创建时在子类构造里调用Base的构造，否则为Base默认构造)
	无论是继承来的父类（is-a），还是组合的成员对象（has-a），只要它们没有默认构造函数，都必须在子类构造函数的初始化列表中手动初始化。

	is-a和has-a一起使用：构造函数：先Base → 再成员对象 → 最后子类对象

	多态时 父类析构函数必须是 virtual 如果用 Base* ptr = new Derived(); delete ptr; 没有 virtual 的话，
	只会调用 Base::~Base()，子类析构函数不会被调用，内存泄露

	在子类写了自己的拷贝构造函数，一定要显式调用父类拷贝构造函数  拷贝构造函数在继承中不会自动调用父类的！
	赋值运算符重载时，也需手动调用父类赋值 	
	要在初始化列表里写父类的相关构造函数
	(以上都是由于函数的重定义导致的)





2 继承的函数重定义(隐藏)和重写(覆盖)
	(1)重定义: 子类中定义了与父类只要同名的函数 (参数列表和返回值可以不同), 会隐藏父类的所有同名函数。
		没有 virtual 也会生效。
		参数列表不需要完全相同。(只要名字一样，父类的被继承，但被隐藏了无法被子类对象直接调用) 
		不支持支持多态	
		作用域不同	

	****重定义(隐藏): 
				子类只在他所在的作用域里查找该函数。
				也可以：Base::fun(......); 去Base作用域里调用，可以用using Base::B_fun; 引入这个作用域
					(必须在子类的同名函数前面，当同名同参则还是子类的)
				静态绑定（编译期决定调用哪个函数）
				不支持支持多态


	(2)重写: 子类中定义了与父类参数完全相同的 virtual 函数，并且在父类中的函数为 virtual，
		函数名、参数列表、返回值完全相同
		父类函数开头是 virtual		
		支持多态	
		子类函数后面建议加 override（C++11）	 建议（防止写错） 除非 derived_obj.Base::func(...);

	****重写(覆盖):
				Derived把Base的函数通过virtual替换成自己的，
				可以通过  Base::B_fun(......)去调用，using也无法使用Base的因为是替换(另外这些函数不是重载)
				动态绑定（运行期决定调用哪个函数）注: Base* pb = new Derived();  (*pb).Base::fun(); 不能 pb->Base::fun();  由于运算顺序是->Base::
				支持多态

	访问父类被重定义或重写函数：d_obj.Base::Bfunc(...); （只要这个函数在当前作用域下是可访问的）
	Base::fun() 只能通过对象名或者**在子类内部使用 Base::fun()**来调用
	
	
	Base* ptr = new Derived();   静态类型是变量定义时的类型Base*    
						      动态类型运行时该指针实际指向的对象类型Derived
	静态绑定是根据“变量的类型”（静态类型）来决定调用哪个函数
	动态绑定是根据“new 出来的对象的类型”（动态类型）来决定调用哪个函数















